# A script to import contacts and messages from sqlite3 dump generated by the
# https://github.com/ostankin/mirandat3 script
#
# Usage:
# python3 scripts/miranda/import-miranda-sqlite3-dump.py contacts -d export.sqlite3 > contacts.json
# python3 scripts/miranda/import-miranda-sqlite3-dump.py messages -d export.sqlite3 -u <user_uin> > messages.json

import sqlite3
import json
import sys
import argparse
from datetime import datetime

def main():
    parser = argparse.ArgumentParser(description="Import contacts and messages from Miranda SQLite dump")
    parser.add_argument("mode", choices=["contacts", "messages"], help="Mode: contacts or messages")
    parser.add_argument("-d", "--database", required=True, help="SQLite database file")
    parser.add_argument("-u", "--user", help="User UIN (for messages mode)")

    args = parser.parse_args()

    mode = args.mode
    db_file = args.database
    user_uin = args.user

    conn = sqlite3.connect(db_file)
    cur = conn.cursor()
    cur_settings = conn.cursor()  # Separate cursor for settings queries

    if mode == 'contacts':
        cur = conn.cursor()

        contacts = []
        for row in cur.execute("SELECT id, name FROM contacts"):
            c_id, name = row
            name = name.decode('utf-8') if isinstance(name, bytes) else name
            settings = {}
            for s_row in cur_settings.execute("SELECT name, value FROM settings WHERE owner = ?", (c_id,)):
                key = s_row[0].decode('utf-8') if isinstance(s_row[0], bytes) else s_row[0]
                val = s_row[1].decode('utf-8') if isinstance(s_row[1], bytes) else s_row[1]
                settings[key] = val
            uin = settings.get('UIN')
            if not uin and 'MyHandle' in settings:
                uin = settings['MyHandle']
            # Always include the contact, use uin or fallback
            platform_id = uin if uin else str(c_id)
            platform = "icq" if uin else "unknown"
            user = {
                "name": name,
                "platform_ids": [{
                    "id": platform_id,
                    "platform": platform,
                    "avatar": "",
                    "meta": settings,
                }]
            }
            contacts.append(user)
        print(json.dumps(contacts, indent=2, ensure_ascii=False))

    elif mode == 'messages':
        if not user_uin:
            # Find user UIN from DB
            for row in cur_settings.execute("SELECT value FROM settings WHERE name = ?", (b'MyHandle',)):
                user_uin = row[0].decode('utf-8') if isinstance(row[0], bytes) else row[0]
                break
        if not user_uin:
            print("User UIN not found. Provide with -u option.")
            sys.exit(1)

        # Build dict of owner to UIN
        uin_dict = {}
        for row in cur.execute("SELECT owner, value FROM settings WHERE name = ?", (b'UIN',)):
            owner = row[0]
            uin_val = row[1].decode('utf-8') if isinstance(row[1], bytes) else row[1]
            uin_dict[owner] = uin_val

        messages = []
        for row in cur.execute("SELECT owner, timestamp, type, data FROM events"):
            owner, ts, typ, data = row
            typ = typ.decode('utf-8') if isinstance(typ, bytes) else typ
            if typ == 'Message':
                data = data.decode('utf-8') if isinstance(data, bytes) else data
                # Parse timestamp string to datetime
                dt = datetime.strptime(ts, '%Y-%m-%d %H:%M:%S')
                # Get UIN of owner
                uin = uin_dict.get(owner)
                if uin:
                    message = {
                        "platform": "icq",
                        "ts": dt.isoformat(),
                        "from": uin,
                        "to": {"type": "user", "user_id": user_uin},
                        "text": data,
                        "raw": None,
                        "attachments": [],
                        "meta": {}
                    }
                    messages.append(message)
        print(json.dumps(messages, indent=2, ensure_ascii=False))

    conn.close()

if __name__ == "__main__":
    main()