# A script to import contacts and messages from sqlite3 dump generated by the
# https://github.com/ostankin/mirandat3 script
#
# Usage:
# python3 scripts/miranda/import-miranda-sqlite3-dump.py contacts -d export.sqlite3 > contacts.json
# python3 scripts/miranda/import-miranda-sqlite3-dump.py messages -d export.sqlite3 -u <user_uin> > messages.json

import argparse
from datetime import timezone
import json
from vendor.mirandat3.mirandat3 import DBHeader, DBContact, Encoder
from collections import OrderedDict

def format_utc_seconds(dt):
    if dt.tzinfo is None:
        dt = dt.replace(tzinfo=timezone.utc)
    return dt.astimezone(timezone.utc).replace(microsecond=0).isoformat().replace('+00:00', 'Z')

def get_platform(p):
    if p == 'JABBER' or p == 'jabber':
        return 'jabber'
    elif p == 'ICQ' or p == 'icq':
        return 'icq'
    elif p == 'IRC' or p == 'irc':
        return 'irc'
    else:
        raise Exception(f"Unknown platform: {p}")


def get_id(settings):
    platform = get_platform(settings["p"])
    if platform == 'icq':
        return settings.setdefault("UIN", "UNKNOWN")
    if platform == 'irc':
        return settings.setdefault("Nick", "UNKNOWN")
    if platform == 'jabber':
        return settings.setdefault("Nick", "UNKNOWN")
    else:
        raise Exception(f"Unknown platform: {platform}")


def get_contact(c: DBContact, on_contact):
    name = str(c.name)
    settings = {}
    for k, v in list(c.settings.items()):
        v = v.decode('utf-8') if isinstance(v, bytes) else str(v)
        settings[k] = v
    on_contact({
        "name": name,
        "platform_ids": [{
            "id": get_id(settings),
            "platform": get_platform(settings["p"]),
            "avatar": "",
            "meta": settings
        }]
    })

def get_messages(c: DBContact, owner_id, on_message):
    platform = get_platform(c.settings.get("p"))
    user_id = get_id(c.settings)
    messages = []
    for e in c.events:
        if e.dir() == '>':
            m_from = user_id
            m_to = {"type": "user", "user_id": owner_id}
        else:
            m_from = owner_id
            m_to = {"type": "user", "user_id": user_id}
        on_message(OrderedDict({
            "ts": format_utc_seconds(e.timestamp),
            "platform": get_platform(platform),
            "from": m_from,
            "to": m_to,
            "text": e.parse_blob(),
            "meta": {
                "type": e.typestr()
            }
        }))

    return messages


def cb_on_message(message):
    print(json.dumps(message, ensure_ascii=False))

def main():
    parser = argparse.ArgumentParser(description="Import contacts and messages from Miranda SQLite dump")
    parser.add_argument("mode", choices=["contacts", "messages"], help="Mode: contacts or messages")
    parser.add_argument("-f", "--file", required=True, help="MirandaIM dat file")
    parser.add_argument("-u", "--user", help="UserID of the owner (for message mode)")
    parser.add_argument("-e", "--encoding", help="Encoding code page", default=Encoder.encoding)

    args = parser.parse_args()
    owner_id = "unknown"
    if args.user:
        owner_id = args.user

    Encoder.encoding = args.encoding

    dat = None
    with open(args.file, 'rb') as f:
        dat = f.read()
    header = DBHeader(dat)

    next_contact = header.firstContact
    contacts = []
    messages = []
    while next_contact != 0:
        c = DBContact(dat, next_contact)
        if args.mode == "contacts":
            get_contact(c, contacts.append)
        if args.mode == "messages":
            messages += get_messages(c, owner_id, cb_on_message)
        next_contact = c.next

    if args.mode == "contacts":
        print(json.dumps(contacts, indent=2, ensure_ascii=False))

if __name__ == "__main__":
    main()